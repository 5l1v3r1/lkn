<chapter id="LKN-recipie">


<!--

  AO: Most of the commands you show should be run as root, right? We
  should show the root prompt as #, not $. This is a subtle little
  convention, but one a lot of readers will recognize. It's also being
  a little more realistic, since those are default prompts.

  gkh: No, you can run lspci and lsusb just fine as a user.  The only
       thing that is needed to be done as root is install the kernel,
       nothing else.
-->

<!--
AO: Some general notes to remember:

I think it could get tiresome to keep saying "Then..." or "Also..."
I think you can just list steps. Readers will assume the steps are
done in order. Sometimes, readers may even want to skip around, so
order is not that important (for xconfig and menuconfig builds). I
did keep one "Also" below because it seemed to fit in well.

Avoid future tense; talk about what the kernel does in the present
(even though it will happen in the future, after building and
booting).

Refer to options such as "SCSI disk support" without any "the." You
can also say 'the "SCSI disk support" option' but there's no need to
add that extra text.
-->
<!--

  AO: A couple more general notes:

About "which" and "that."  You should use "which" for an extra clause
that isn't strictly needed for the sentence to make sense.  If the
clause could be removed and the sentence would still work, use
"which." Also use commas around the clause, as shown here:

        I can't stand being outside when my neighber uses a
        gas-powered lawn mower, which runs at about 110 decibels.

When the clause is required, use "that" and no commas:

        I can't stand being outside when my neighber uses a
        gas-powered lawn mower that runs at about 110 decibels.

(In other words, I can tolerate other kinds of gas-powered lawn mowers.)

To use English-teacher jargon, one uses "that" for descriptive clauses and "which" for restrictive ones.

The British tend to use "which" a lot where American usage is "that."

...

Using "such as" and "like": this is not very important, but our style
guide distinguishes between these. If you are citing EXAMPLES of
something, use "such as." For instance:

	Large companies such as IBM and Hewlett Packard promote
	Linux...

Reserve "like" for more metaphorical situations; these are NOT
examples.

	People treat the claims of these large companies like
	politicians.

...

The word "only." Very important and valuable, but I like to use it in
the right place as defined by English experts. Most writers aren't
sticklers as much as I am, but I think doing it right really makes
things clear for the reader.  The rule is: "Use 'only' before the word
that it modifies." Here are two sentences that show how the location
of "only" makes a difference:

	This network layer only reads the headers on the packets.
	This network layer reads only the headers on the packets.

The first sentence implies, "The layer reads the headers but does not
create or write them." The second sentence implies, "The layer reads
headers but not the contents of the data (for the purposes of
check-summing, etc.)." Probably the writer in this case wants the
latter meaning. But many writers would write the first sentence, which
is formally incorrect and could confuse the reader.

-->


<title>
Kernel Configuration Recipes
</title>


<sect1>
<title>Disks</title>

<simplesect>

<!--

  AO: We should have a little text between sect1 and sect2, although
  it's not absolutely required in a reference work. I just put in some
  junk that I thought might set a context; you can change it.

-->
<para>
The Linux kernel supports a wide range of different disk types.
This section shows how to make sure the kernel can
support a few of the more common types of disk controllers.
</para>

</simplesect>

<sect2 id="lkn_usb_storage">
<title>USB storage</title>

<para>
To use a USB storage device (commonly referred to as USB "flash"
devices) USB support must be first working properly.  Refer to the recipe
in <xref linkend="lkn_usb" /> for how to do this.
</para>

<para>
A USB storage device can be identified by using the
<literal>lsusb</literal> program.  If the following command sequence
produces the expected result, a USB storage device is present on the
system:
</para>

<!-- gkh -
	What is the proper formatting for typing things on the command
	line and the result?
-->
<screen>
$ <userinput>/usr/sbin/lsusb -v | grep Storage</userinput>
      bInterfaceClass         8 Mass Storage
</screen>

<!--

  AO: I don't want to add a lot of extra work for you, but it occurred
  to me when looking at the HTML output that a lot of instructions
  might look better as numbered lists. Try it out. Would it be a lot
  of work to use numbered lists as I've done in this one example?

-->

<para>
Enable it as follows.
</para>

<orderedlist>

<listitem>
<para>
A USB Storage device is in reality a USB SCSI device that talks over a
USB connection.  Because of this, the SCSI subsystem must be enabled:
<screen>
Device Drivers
    SCSI Device Support
        [*] SCSI Device Support
</screen>
</para>
</listitem>

<listitem>
<para>
Also in the SCSI system, the "SCSI disk support" must be enabled in
order for the device to be mounted properly:
<screen>
Device Drivers
	SCSI Device Support
		[*] SCSI disk support
</screen>
</para>
</listitem>

<listitem><para>
Enable USB Storage support:
<screen>
Device Drivers
	USB Support
	[M] USB Mass Storage support
</screen>
</para></listitem>

</orderedlist>

<para>
A number of specific USB storage devices are listed as separate
configuration items, as they do not follow the standard USB
specification and require special code.  If you have one of these
devices, please enable support for them.
</para>
</sect2>

<sect2 id="lkn_ide">
<title>IDE Disks</title>

<para>
IDE disks are the most common type of PC disk controllers.
To determine if you have a IDE disk controller on the system, run the
following command:
<screen>
$ <userinput>/usr/sbin/lspci | grep IDE</userinput>
00:1f.1 IDE interface: Intel Corporation 82801EB/ER (ICH5/ICH5R) IDE Controller (rev 02)
00:1f.2 IDE interface: Intel Corporation 82801EB (ICH5) SATA Controller (rev 02)
</screen>
Note that your response will probably not match identically, all that is
important is that the command shows some an IDE Controller (the first
device in the above example.)  If you only show a SATA controller, please
see <xref linkend="lkn_sata" />.
</para>

<para>
Enable PCI support for the kernel:
<screen>
Bus Options (PCI, PCMCIA, EISA, MCA, ISA)
    [*] PCI Support
</screen>

Enable the IDE subsystem, and IDE support:
<screen>
Device Drivers
    [*] ATA/ATAPI/MFM/RLL support
    [*]   Enhanced IDE/MFM/RLL disk/cdrom/tape/floppy support
</screen>

In the ATA system, the specific type of IDE controller that you have must
be enabled in order for it to work properly.  To provide a good backup
incase you choose the wrong type, select the "generic" IDE controller:
<screen>
Device Drivers
    ATA/ATAPI/MFM/RLL support
        [*]     generic/default IDE chipset support
</screen>

Enable the different PCI IDE controllers:
<screen>
Device Drivers
    ATA/ATAPI/MFM/RLL support
        [*]     PCI IDE chipset support
</screen>

This opens up a wide submenu of the different IDE controller types.  Select
the proper one based on the name of the device you found in the original
step.
</para>

</sect2>

<sect2 id="lkn_sata">
<title>Serial ATA (SATA)</title>

<para>
SATA is a type of disk controller that is the successor to the IDE bus.
To determine if you have a SATA disk controller on the system, run the
following command:
<screen>
$ <userinput>/usr/sbin/lspci | grep SATA</userinput>
00:1f.2 IDE interface: Intel Corporation 82801EB (ICH5) SATA Controller (rev 02)
</screen>
Note that your response will probably not match identically, all that is
important is that the command shows some SATA devices.
</para>

<para>
SATA disks use a kernel library called <emphasis>libata</emphasis> that handles most of the
SATA specific functionality.  That library uses the SCSI layer to talk
to the block layer, so many different kernel options need to be enabled
in order for SATA disks to work properly.
Enable PCI support for the kernel:
<screen>
Bus Options (PCI, PCMCIA, EISA, MCA, ISA)
	[*] PCI Support
</screen>

Enable the SCSI subsystem:
<screen>
Device Drivers
	SCSI Device Support
		[*] SCSI Device Support
</screen>

Also in the SCSI system, the "SCSI disk support" option must be enabled in
order for the device to be mounted properly:
<screen>
Device Drivers
	SCSI Device Support
		[*] SCSI disk support
</screen>

The SATA options are under the "SCSI low-level drivers" section:
<screen>
Device Drivers
	SCSI Device Support
		SCSI low-level drivers
			[*] Serial ATA (SATA) support
</screen>

In that section, enable the specific SATA controller type that you have.
Look at the output of the above mentioned <literal>lspci</literal>
command for a list of the types of SATA controllers that are present on
your system.  For example, most motherboards from Intel would require the PIIX/ICH
SATA driver (as the above example showed.)
<screen>
Device Drivers
	SCSI Device Support
		SCSI low-level drivers
			[*] Serial ATA (SATA) support
			[*]   Intel PIIX/ICH SATA support
</screen>


</para>
</sect2>

<sect2 id="lkn_burn_cdrom">
<title>Burning a CDROM</title>

<para>
Burning a CDROM is very simple on Linux.  If your kernel can support
reading from a CDROM, then it can also support burning from it.  There are
two different ways to enable CDROM support in Linux:
</para>

<sect3>
<title>IDE CDROM drives</title>

<para>
IDE CDROM drives are controlled by the same IDE controller as your main IDE
disk drives.  Make sure the IDE controller is properly supported as
described in <xref linkend="lkn_ide" />.  If that is properly supported,
then the IDE CDROM drive needs no other kernel configuration in order to
properly use it.
</para>

</sect3>

<sect3>
<title>SCSI / SATA CDROM drives</title>

<para>
SATA and SCSI cdrom drives are controlled by the same controller as your
main disk drives.  Make sure the SATA or SCSI controller is properly
supported.  For SATA disks, see <xref linkend="lkn_sata" />.
</para>

<para>
To support SATA or SCSI CDROM drives, the SCSI cdrom driver must be
enabled:
<screen>
Device Drivers
	SCSI Device Support
		[*] SCSI CDROM support
</screen>

Once that is enabled, the SATA or SCSI CDROM drive will work properly.
</para>

</sect3>
</sect2>
</sect1>

<sect1>
<title>Devices</title>

<simplesect>
Linux supports a vast range of different types of devices (more than any
other operating system ever has).  This section shows how to enable
some of the more common types.
</simplesect>

<sect2 id="lkn_usb">
<title>USB</title>

<para>
Linux supports lots of different types of USB devices.  To enable USB
support, you must first enable support for a USB controller, which
drives the USB connection on the machine.
</para>

<para>
To determine if your machine has a USB controller present, and which type
is is, run the following command:
<screen>
$ <userinput>/usr/sbin/lspci | grep USB</userinput>
00:1d.0 USB Controller: Intel Corporation 82801EB/ER (ICH5/ICH5R) USB UHCI Controller #1 (rev 02)
00:1d.1 USB Controller: Intel Corporation 82801EB/ER (ICH5/ICH5R) USB UHCI Controller #2 (rev 02)
00:1d.2 USB Controller: Intel Corporation 82801EB/ER (ICH5/ICH5R) USB UHCI Controller #3 (rev 02)
00:1d.3 USB Controller: Intel Corporation 82801EB/ER (ICH5/ICH5R) USB UHCI Controller #4 (rev 02)
00:1d.7 USB Controller: Intel Corporation 82801EB/ER (ICH5/ICH5R) USB2 EHCI Controller (rev 02)
</screen>
Note that your response will probably not match identically, all that is
important is that the command shows some USB controllers.
</para>

<para>
Enable PCI support for the kernel:
<screen>
Bus Options (PCI, PCMCIA, EISA, MCA, ISA)
	[*] PCI Support
</screen>

Enable USB support for the kernel:
<screen>
Device Drivers
	USB Support
		[M] Support for Host-side USB
</screen>

Enable the specific USB Host controllers for your machine (it is safe to
enable them all if you do not know which you have):
<screen>
Device Drivers
	USB Support
	---   USB Host Controller Drivers
	[M]   EHCI HCD (USB 2.0) support
	[M]   OHCI HCD support
	[M]   UHCI HCD (most Intel and VIA) support
</screen>

Individual USB devices also need their drivers to be enabled.  A large
majority of them are under the main USB driver section:
<screen>
Device Drivers
	USB Support
</screen>
<!--

  AO: I think it's a good idea to put names of menu items in <literal>
  tags. That's because some names may be long phrases that look odd
  when dropped in a sentence; they need a font change. On the other
  hand, something such "main USB driver section" is a generic
  reference to USB; it's safe to leave that in plain font. Use what
  feels right in each case.

-->

But some, such as USB video and DVB and sound devices are listed in the
section controlling all of these types of devices.  For example, the USB
sound driver can be found under the <literal>Sound</literal> menu:
<screen>
Device drivers
	Sound
		[*] Sound card support
			[*] Advanced Linux Sound Architecture
				USB Devices
					[M] USB Audio/MIDI driver
</screen>
</para>

<!--

  AO: I thought it would be nice to point readers to the next step,
  should they need it. Would it load the book down too much to put
  "next step" paragraphs like this in?

-->

<para>

If you want to insert USB storage devices (USB flash), look now at
<xref linkend="lkn_usb_storage" />.

</para>

</sect2>

<sect2 id="lkn_firewire">
<title>IEEE 1394 (FireWire)</title>

<para>
IEEE 1394 is commonly known by the name FireWire, under which Apple
Computer publicized it. It is a
highspeed bus that connects external devices, much as USB does.
</para>

<para>
<!--

  AO: Notice how I use "whether" instead of "if" when you're trying to
  determine whether something is true. A minor nit.

-->
To determine whether your machine has a FireWire controller present, and which type
is is, run the following command:
<screen>
$ <userinput>/usr/sbin/lspci | grep FireWire</userinput>
06:0c.0 FireWire (IEEE 1394): Texas Instruments TSB43AB22/A IEEE-1394a-2000 Controller (PHY/Link)
06:0d.2 FireWire (IEEE 1394): Creative Labs SB Audigy FireWire Port (rev 04)
</screen>
Note that your response will probably not match identically; all that's
important is that the command shows some FireWire controllers.
</para>

<para>
Enable PCI support for the kernel:
<screen>
Bus Options (PCI, PCMCIA, EISA, MCA, ISA)
	[*] PCI Support
</screen>

Enable IEEE 1394 support for the kernel:
<screen>
Device Drivers
	IEEE 1394 (FireWire) support
		[*] IEEE 1394 (FireWire) support
</screen>

Enable the specific type of Firewire host controller that you have:
<screen>
Device Drivers
	IEEE 1394 (FireWire) support
		[*] IEEE 1394 (FireWire) support
		---   Device Drivers
		[M]   Texas Instruments PCILynx support
		[M]   OHCI-1394 support

</screen>

And enable the specific type of Firewire devices that you have:
<screen>
Device Drivers
	IEEE 1394 (FireWire) support
		[*] IEEE 1394 (FireWire) support
		---   Protocol Drivers
		[M]   OHCI-1394 Video support
		[M]   SBP-2 support (Harddisks etc.)
		[ ]     Enable Phys DMA support for SBP2 (Debug)
		[M]   Ethernet over 1394
		[M]   OHCI-DV I/O support
		[M]   Raw IEEE1394 I/O support
</screen>
</para>
</sect2>

<sect2 id="lkn_pci_hotplug">
<title>PCI hotplug</title>

<para>
PCI hotplug systems are becoming more popular with the use of
ExpressCard and laptop docking stations.
</para>

<para>
To determine whether your machine has a ExpressCard controller present, and
which type is is, run the following command:
<screen>
FIXME!!!
</screen>
Note that your response will probably not match identically; all that's
important is that the command shows some controllers.
</para>

<para>
Enable PCI support for the kernel:
<screen>
Bus Options (PCI, PCMCIA, EISA, MCA, ISA)
	[*] PCI Support
</screen>
Enable PCI Hotplug support for the kernel:
<screen>
Bus Options (PCI, PCMCIA, EISA, MCA, ISA)
	[*] PCI Support
	PCI Hotplug Support
		[M] Support for PCI Hotplug (EXPERIMENTAL)
</screen>

There is a wide range of different types of PCI Hotplug controllers.
For most laptops and for ExpressCard support, enable the ACPI
controller:
<screen>
Bus Options (PCI, PCMCIA, EISA, MCA, ISA)
	[*] PCI Support
	PCI Hotplug Support
		[M] Support for PCI Hotplug (EXPERIMENTAL)
		[M]   ACPI PCI Hotplug driver
</screen>

As well as the PCI Express controller:
<screen>
Bus Options (PCI, PCMCIA, EISA, MCA, ISA)
	[*] PCI Support
	[*] PCI Express Support
	[M]   PCI Express Hotplug driver
</screen>
</para>
</sect2>

<sect2 id="lkn_pcmcia">
<title>PCMCIA / CardBus</title>

<!--

  AO: Let's make sure to do cross-references in a way that will
  translate during conversion; see what I did with xref.

-->
<para>
PCMCIA and CardBus device support is in almost every laptop manufactured.  Newer
laptops, however, are switching to the ExpressCard format (see the PCI Hotplug
recipe in <xref linkend="lkn_pci_hotplug" />).
</para>

<para>
To determine whether your machine has a PCMCIA controller present, and which
type is is, run the following command:
<screen>
FIXME!!!
</screen>
Note that your response will probably not match identically; all that's
important is that the command shows some controllers.
</para>

<para>
Enable PCI support for the kernel:
<screen>
Bus Options (PCI, PCMCIA, EISA, MCA, ISA)
	[*] PCI Support
</screen>

Enable PCCARD support for the kernel:
<screen>
Bus Options (PCI, PCMCIA, EISA, MCA, ISA)
	PCCARD (PCMCIA/CardBus) support
		[M] PCCard (PCMCIA/CardBus) support
</screen>

Enable both PCMCIA and CardBus support to cover the widest range of
devices:
<screen>
Bus Options (PCI, PCMCIA, EISA, MCA, ISA)
	PCCARD (PCMCIA/CardBus) support
		[M] PCCard (PCMCIA/CardBus) support
		[M]   16-bit PCMCIA support
		[*]   32-bit CardBus support
</screen>

Enable the card bridge type for your laptop.  The most common one is the
"yenta-like" controller:
<screen>
Bus Options (PCI, PCMCIA, EISA, MCA, ISA)
	PCCARD (PCMCIA/CardBus) support
		[M] PCCard (PCMCIA/CardBus) support
		[M]   CardBus yenta-compatible bridge support
		[ ]   Cirrus PD6729 compatible bridge support
		[ ]   i82092 compatible bridge support
		[ ]   i82365 compatible bridge support
		[ ]   Databook TCIC host bridge support
</screen>
</para>
</sect2>

<sect2 id="sound">
<title>Sound (ALSA)</title>

<para>
ALSA (Advanced Linux Sound Architecture) is the current sound
system for the Linux kernel.  An earlier sound system (OSS) has
been depreciated and almost all of the older drivers have been removed
from the kernel source tree.
</para>

<para>
To determine which type of sound controller is present in your machine,
and what type it is, run the following command:
<screen>
$ <userinput>/usr/sbin/lspci | grep -i audio</userinput>
00:1f.5 Multimedia audio controller: Intel Corporation 82801EB/ER (ICH5/ICH5R) AC'97 Audio Controller (rev 02)
06:0d.0 Multimedia audio controller: Creative Labs SB Audigy (rev 04)
</screen>
Note that your response will probably not match identically; all that's
important is that the command shows some FireWire controllers.
</para>

<para>
Enable basic sound support:
<screen>
Device Drivers
    Sound
        [M] Sound Card Support
</screen>
Enable ALSA:
<screen>
Device Drivers
    Sound
        [M] Sound Card Support
            [M] Advanced Linux Sound Architecture
</screen>
There are a number of different base ALSA options, such as support for
the older <literal>OSS</literal> sound protocol.  If you have older
applications, you should enable these options:
<screen>
Device Drivers
    Sound
        [M] Sound Card Support
            [M] Advanced Linux Sound Architecture
            [M]   OSS Mixer API
            [M]   OSS PCM (digital audio) API
            [ ]     OSS PCM (digital audio) API - Include plugin system
</screen>

Enable the specific type of sound device that you have.  PCI sound cards
are under the PCI submenu:
<screen>
Device Drivers
    Sound
        [M] Sound Card Support
            [M] Advanced Linux Sound Architecture
                PCI Devices
</screen>


</para>
</sect2>

</sect1>

<sect1>
<title>CPU</title>

<simplesect>

<para>
If you wish to have the Linux kernel to run the fastest for your specific
processor and hardware type, there are a few different options that you can
set to get the last bit of performance out of the hardware.  This section
will show some of the different processor specific options that you can
tune for your processor.
</para>

</simplesect>

<sect2 id="processor">
<title>Processor Types</title>

<para>
There are a wide range of specific processor options that are available to
be changed in the Linux kernel.  The most important one is specifying the
exact type of CPU you are using this kernel for.  To determine the type of
processor you are using, run the following command:
<screen>
$ <userinput>cat /proc/cpuinfo  | grep "model name"</userinput>
model name      : Intel(R) Xeon(TM) CPU 3.20GHz
</screen>
Note that your response will probably not match identically, all that is
important is that the command shows the model name of the processor present
on the system.
</para>

<para>
Select the subarchitecture type of the processor:
<screen>
Processor type and features
    Subarchitecture Type
        (X) PC-compatible
        ( ) AMD Elan
        ( ) Voyager (NCR)
        ( ) NUMAQ (IBM/Sequent)
        ( ) Summit/EXA (IBM x440)
        ( ) Support for other sub-arch SMP systems with more than 8 CPUs
        ( ) SGI 320/540 (Visual Workstation)
        ( ) Generic architecture (Summit, bigsmp, ES7000, default)
        ( ) Support for Unisys ES7000 IA32 series
</screen>
Only if you have a machine of the other types in the above list should you
select anything other than the <literal>PC-compatible</literal> option.
However, if you wish to create a single kernel that will run on all of the above
types of machines, then select the <literal>Generic architecture</literal>
option.
</para>

<para>
Select the processor family type.  The <literal>PC-compatible</literal>
option needs to be first selected from the above options for this submenu
to be able to be selected:
<screen>
Processor type and features
    Processor family
        ( ) 386
        ( ) 486
        ( ) 586/K5/5x86/6x86/6x86MX
        ( ) Pentium-Classic
        ( ) Pentium-MMX
        ( ) Pentium-Pro
        ( ) Pentium-II/Celeron(pre-Coppermine)
        ( ) Pentium-III/Celeron(Coppermine)/Pentium-III Xeon
        ( ) Pentium M
        (X) Pentium-4/Celeron(P4-based)/Pentium-4 M/Xeon
        ( ) K6/K6-II/K6-III
        ( ) Athlon/Duron/K7
        ( ) Opteron/Athlon64/Hammer/K8
        ( ) Crusoe
        ( ) Efficeon
        ( ) Winchip-C6
        ( ) Winchip-2
        ( ) Winchip-2A/Winchip-3
        ( ) GeodeGX1
        ( ) Geode GX/LX
        ( ) CyrixIII/VIA-C3
        ( ) VIA C3-2 (Nehemiah)
        ( ) Generic x86 support
</screen>
The help option for this configuration value provides a lot of description
about how to pick the proper processor type depending on what processor you
have, and what range of machines you wish the kernel to run on.  Please
refer to that for more detail.
</para>

</sect2>

<sect2 id="smp">
<title>SMP</title>

<para>
If the machine you are using for Linux contains more than one CPU, or a
Hyperthreaded or Dual Core CPU, then you should select the multiprocessor
option for the Linux kernel in order to take advantage of the additional
processors.
</para>

<para>
Enable multiprocessing:
<screen>
Processor type and features
    [*] Symmetric multi-processing support
</screen>
</para>

</sect2>

<sect2 id="preempt">
<title>Preemption</title>

<para>
Systems running as a server have very different workload requirements than
those being used as a desktop for video and audio applicatons.  The kernel
allows different modes of "preemption" in order to handle these different
workloads.  Preemption is the ability of the kernel to interrupt itself
while it is doing something else, in order to work on something with a
higher priority, like updating a sound or video program.
</para>

<para>
To change the different preemption model:
<screen>
Processor type and features
    Preemption Model
        (X) No Forced Preemption (Server)
	( ) Voluntary Kernel Preemption (Desktop)
	( ) Preemptible Kernel (Low-Latency Desktop)
</screen>
</para>

<para>
If you wish to make the kernel even more responsive to higher priority
tasks than the general preemption option provides, you can also interrupt
one of the main internal kernel locks:
<screen>
Processor type and features
    [*] Preempt The Big Kernel Lock
</screen>
This option will only be able to be selected if you have already selected
either the <literal>Preemptable Kernel</literal> or <literal>Symmetric
multi-processing support</literal> options.
</para>


</sect2>

<sect2 id="suspend">
<title>Suspend</title>

<para>
The Linux kernel has the ability to suspend itself to disk allowing you to
disconnect the power, and then at a later time, power up and resume exactly
where the machine was when it was suspended.  This functionality is very
useful on laptops that run Linux.
</para>

<para>
Enable this by selecting:
<screen>
Power management options (ACPI, APM)
    [*] Software Suspend
</screen>

The kernel needs to know where to save off the suspended kernel image, and
then later where to resume it from.  This is usually a kernel swap
partition on the disk.  To specify which partition this should be:
<screen>
Power management options (ACPI, APM)
    (/dev/hda3) Default resume partition
</screen>
Note: make sure you specify the proper partition to suspend the machine to,
and do not use a partition that is being used by the system for data.  This
partition name can be found by running the following command:
<screen>
$ <userinput>/sbin/swapon -s | grep dev | cut -f 1 -d ' '</userinput>
/dev/hda3
</screen>
Use the output of the above command in this kernel configuration option,
and on the kernel boot line where it specifies the kernel should be resumed
from.  See the configuration help for this option for more information
about how to specify the resume partition and how to suspend the kernel.
</para>

</sect2>


<sect2 id="cpufreq">
<title>CPU Frequency Scaling</title>

<para>
Most modern processors have the feature to slow down the internal clock of
processor in order to conserve power and battery life.  Linux supports this
ability and offers a wide range of different type of power "governors".
Different governors implement different heursitcs in order to determine how
to speed up and slow down the processor depending on the system load and
other variables.
</para>

<para>
Enable the basic frequency scaling functionality:
<screen>
Power management options (ACPI, APM)
    [*] CPU Frequency scaling
</screen>

Select the different type of frequency governors you wish to use:
<screen>
Power management options (ACPI, APM)
    [*] CPU Frequency scaling
    [*]   'performance' governor
    [*]   'powersave' governor
    [*]   'userspace' governor for userspace frequency scaling
    [*]   'ondemand' cpufreq policy governor
    [*]   'conservative' cpufreq governor
</screen>

Select the default governor you wish to have running when the maching
boots:
<screen>
Power management options (ACPI, APM)
    [*] CPU Frequency scaling
          Default CPUFreq governor (performance)
</screen>

Select the specific processor type the machine has.  For details on how to
determine the processor type of the machine, see
<xref linkend="processor" /> for how to do this.

<screen>
Power management options (ACPI, APM)
    [*] CPU Frequency scaling
    ---   CPUFreq processor drivers
    [ ]   ACPI Processor P-States driver
    [ ]   AMD Mobile K6-2/K6-3 PowerNow!
    [ ]   AMD Mobile Athlon/Duron PowerNow!
    [ ]   AMD Opteron/Athlon64 PowerNow!
    [ ]   Cyrix MediaGX/NatSemi Geode Suspend Modulation
    [*]   Intel Enhanced SpeedStep
    [*]     Use ACPI tables to decode valid frequency/voltage pairs
    [*]     Built-in tables for Banias CPUs
    [ ]   Intel Speedstep on ICH-M chipsets (ioport interface)
    [ ]   Intel SpeedStep on 440BX/ZX/MX chipsets (SMI interface)
    [ ]   Intel Pentium 4 clock modulation
    [ ]   nVidia nForce2 FSB changing
    [ ]   Transmeta LongRun
</screen>
</para>

</sect2>

<sect2 id="mm">
<title>Different Memory <odels</title>

<para>
Linux on Intel 32bit hardware has the ability to access up to 64
</para>

</sect2>

<sect2 id="acpi">
<title>ACPI</title>
</sect2>

</sect1>

<sect1>
<title>Networking</title>

<sect2 id="netfilter">
<title>Netfilter</title>
</sect2>

<sect2 id="netdrv">
<title>network drivers</title>
</sect2>

<sect2 id="irda">
<title>Irda</title>
</sect2>

<sect2 id="wireless">
<title>wireless</title>
</sect2>

</sect1>

<sect1>
<title>Filesystems</title>
<simplesect>
</simplesect>

<sect2 id="raid">
<title>RAID</title>
</sect2>

<sect2 id="lvm">
<title>LVM</title>
</sect2>

<sect2 id="dm">
<title>DM</title>
</sect2>

<sect2 id="samba">
<title>Samba</title>
</sect2>

<sect2 id="journal_fs">
<title>Journaling filesystems</title>
</sect2>

<sect2 id="ocfs2">
<title>OCFS2</title>
</sect2>

</sect1>

<sect1>
<title>Security</title>

<simplesect>
</simplesect>

<sect2 id="selinux">
<title>SELinux</title>
</sect2>

<!--  If this makes it into the kernel tree, uncomment this section...
<sect2 id="apparmor">
<title>AppArmor</title>
-->

</sect1>

<sect1>
<title>Kernel debugging</title>

<simplesect>
<para>
There are a wide range of different kernel options that can help in
debugging what is going on within the kernel.  Following is a list of some
of the more common one that can be useful for discovering new things
about how the kernel works, or help find potential problems within the
current kernel source code.
</para>

</simplesect>

<sect2 id="debug_printk">
<title>Kernel log timestamps</title>

<para>
The kernel outputs a wide range of messages to its log file.  These
messages can be seen by looking at the system log file (usually located
in <filename>/var/log/messages</filename>, or can be seen by running the
<command>dmesg</command> command.
</para>

<para>
Sometimes it is useful to see exactly when those messages were created .
<command>dmesg</command>, however, does not put any timestamps on the
events it shows, and the time resolution of
<literal>/var/log/messages</literal> is only to the nearest
second. 
You can configure the kernel to assign each message a timestamp that is accurate down to
the smallest measurable kernel time value (usually in the microsecond
range.)
</para>

<para>
To enable timestamp options on kernel messages:
<screen>
Kernel hacking
    [*] Show timing information on printks
</screen>
</para>

</sect2>

<sect2 id="sysrq">
<title>Magic SysRq keys</title>

<para>
The <literal>SysRq</literal> key on the keyboard can be used to control
the kernel in a wide range of different ways while the kernel is
running, or if it has crashed.
</para>

<para>
To enable this option:
<screen>
Kernel hacking
    [*] Magic SysRq key
</screen>
</para>

<para>
For a full description of the different actions that can be triggered by
this option, please see the file,
<filename>Documentation/sysrq.txt</filename> in the kernel source tree.
</para>
</sect2>

<sect2 id="debugfs">
<title>Debug Filesystem</title>

<para>
A RAM-based filesystem can be used to output a lot of
different debugging information.  This filesystem is called
<literal>debugfs</literal> and can be enabled by:
<screen>
Kernel hacking
    [*] Debug filesystem
</screen>
</para>

<para>
After you enable this option and booting the rebuilt kernel, it
creates the directory
<filename>/sys/kernel/debug</filename> as a location for the user to mount
the <literal>debugfs</literal> filesystem. Do this manually by:
<screen>
$ <userinput>mount -t debugfs none /sys/kernel/debug</userinput>
</screen>
or have the filesystem mounted automatically at boot time by adding the
following line to the <filename>/etc/fstab</filename> file:
<screen>
debugfs /sys/kernel/debug debugfs 0 0
</screen>
</para>

<para>
After you mount <literal>debugfs</literal>, a large number of
different directories and files will turn up in the <literal>/sys/kernel/debug/</literal>
directory. These are all virtual and dynamically generated by the
kernel, like the files in <literal>procfs</literal> or
<literal>sysfs</literal>. These can be used to help debug different kernel
subsystems, or just looked at to see what is happening to the system as it
runs.
</para>
</sect2>

<sect2 id="debug">
<title>General Kernel Debugging</title>

<para>
Here are a range of other good kernel configuration options that you might
wish to enable if you want to help kernel developers debug different
problems, or just learn more about how the kernel works by looking at the
messages that these options print out.  Note that if you enable almost any
of these options, the kernel will slow down a small ammount, so if you
notice any decrease in performance, you might wish to disable these
options.
<screen>
Kernel hacking
    [*] Kernel debugging
    [*]   Detect Soft Lockups
    [ ]   Collect scheduler statistics
    [*]   Debug slab memory allocations
    [*]     Memory leak debugging
    [*]   Mutex debugging, deadlock detection
    [*]   Spinlock debugging
    [*]   Sleep-inside-spinlock checking
    [ ]   kobject debugging
    [ ]   Highmem debugging
    [ ]   Compile the kernel with debug info
</screen>
</para>

</sect2>

</sect1>


</chapter>
<!-- vim: set ai tw=72 : -->
