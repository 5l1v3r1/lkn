<chapter id="LDSP-chapter-driver_core">

<title>
Introduction
</title>

<simplesect>

<para>
During the 2.5 kernel development cycle, a new kernel device driver
model was introduced.  This model was created to try to help integrate
the vast range of different kernel driver subsystems into one coherent
model.  As a result of this development, a lot of duplicated code has
been removed, and a more cohesive feeing among the different driver
subsystems has occurred.
</para>

<para>
The kernel driver model consists of three main parts, busses, classes,
and devices.
</para>

<para>
A bus is something that has a physical or virtual device
connected to it.  Examples of busses are the PCI, USB, i2c, PCMCIA, and
SCSI busses.  A bus driver provides a type of "bridge" that connects a
bus that the bus device is on, to the new bus. 
</para>

<para>
A class provides a function to a user.  Classes are not specific to only
one bus, and allow devices that talk on different busses to all interact
with the user in a common way.  Examples of classes are audio (like
speakers and microphones), input (like keyboards and mice), disks,
network connections, and tty connections(serial ports and consoles).
</para>

<para>
A device is a physical or virtual entity that resides on a specific bus,
and interacts with a user through a specific class.  Examples of devices
are ethernet controllers, keyboards, mice, serial ports, sound cards,
CPU temperature sensors, and video cards.
</para>

<para>
The majority of kernel device drivers live at an intersection the bus
and class axis of a grid, providing a driver that knows how to
communicate across a specific bus, to a specific class.
</para>


</simplesect>

<sect1>
	<title>Busses</title>

	<para>
		A bus is something that has a physical or virtual device
		connected to it.  Examples of busses are the PCI, USB, i2c,
		PCMCIA, and SCSI busses.  A bus driver provides a type of
		"bridge" that connects a bus that the bus device is on, to the
		new bus.  As an example, a USB controller is almost always a PCI
		device.  This PCI device allows the computer to talk to the USB
		bus that is connected to the controller.  The USB controller
		driver mediates the connection between the two different types
		of busses (PCI and USB in this example.)
	</para>

	<remark>
		A drawing of the PCI bus, USB controller, and USB bus would
		probably be good here.
	</remark>

	<para>
		Usually there is only one bus driver that controls the activity
		on the bus.
	</para>

	<para>
		Busses are represented in the kernel with the struct bus_type
		definition, found in <filename>include/linux/device.h</filename>.
		An example of how to declare a bus_type variable can be seen in
		the <filename>drivers/i2c/i2c-core.c</filename> file:
		<programlisting>
struct bus_type i2c_bus_type = {
	.name =		"i2c", 
	.match =	i2c_device_match,
	.hotplug =	i2c_hotplug,
};
		</programlisting>
	</para>

	<para>
		The <literal>name</literal> field is a pointer to a string that
		will be used to describe this bus within the kernel.  It can not
		be longer than the <literal>KOBJ_NAME_LEN</literal> size, which
		is defined in <filename>include/linux/kobject.h</filename>.  The
		different fields of the <literal>struct bus_type</literal> will
		be described later.
	</para>

	<para>
		A bus will contain a list of the different drivers and devices
		that have been registered with it.  All drivers and devices that
		are registered to a bus should be of the same structure type, as
		will be described below.  A driver and device is assigned to a
		bus before they are registered with the driver core, a bus does
		not have to do any registering of drivers or devices itself.
	</para>

<sect2>
		<title>Register and Unregister a Bus</title>

		
	<para>
		A bus must be registered with the device core.  To do this, the
		<function>bus_register</function> function should be called with
		a pointer to the bus_type structure:
		<programlisting>
	retval = bus_register(&amp;i2c_bus_type);
	if (retval)
		return retval;
		</programlisting>
	</para>

	<para>
		Similarily, when the driver subsystem that had previously
		registered the bus_type is shutting down,
		<function>bus_unregister</function> should be called to
		unregister the bus_type:
		<programlisting>
	bus_unregister(&amp;i2c_bus_type);
		</programlisting>
	</para>

</sect2>

<sect2>
	
	<title>Bus Match</title>
	
	<para>
		The match variable is a pointer to a function that will be
		called by the driver core when a new device is added to the
		kernel for this specific bus.  This function is responsible for
		determining if the specified driver will support the specified
		device.  This can not be done within the driver core, as every
		bus has a different algorithm for determining if a driver and
		device match up.  An example of how this function might be
		implemented can be seen in the following code from
		<literal>i2c-core.c</literal>:
		<programlisting>
static int i2c_device_match (struct device *dev, struct device_driver *drv)
{       
	struct i2c_driver *i2c_drv;
	struct i2c_client *i2c_dev;
	const struct i2c_device_id *id;

	i2c_dev = to_i2c_client(dev);
	i2c_drv = to_i2c_driver(drv);

	id = i2c_match_id (i2c_dev, i2c_drv-&gt;id_table);
	if (id)
		return 1;

	return 0;
}
		</programlisting>
	</para>
	
	<para>
		In this function, the <literal>struct device</literal> pointer,
		and the <literal>struct device_driver</literal> pointer are cast
		to the proper types for the i2c subsystem through the use of the
		<literal>to_i2c_client</literal> and
		<literal>to_i2c_driver</literal> macros.
		Then the <literal>i2c_match_id</literal> function is called
		which determines if this specific i2c device is supported by
		this specific i2c driver.  If so, it returns a pointer to the
		valid id structure that caused the match, and the function
		returns that this is a valid match to the driver core.  If the
		match fails, the function returns 0, stating that this is not a
		match.
	</para>

	<para>
		By using the match function, the driver core prevents every
		driver registered with a specific bus from having to be asked
		directly if it supports a specific device.  By the use of device
		id structures, drivers tell the driver core what kind of devices
		they support.  This device id structure is also exported to
		userspace, allowing the <filename>/sbin/hotplug</filename> tool to
		automatically load drivers when devices are seen by the system.
		
		<remark>
			Should I go into the the device id exporting and how it
			is set up, and works?  I have lots of info on this...
		</remark>
	</para>


<sect3>
	<title>
		<function>container_of</function>
	</title>

	<remark>
		Here's some info on how the whole to_*() macros work, should it
		go here, or somewhere else?  I think they should go somewhere,
		as they are a constant source of confusion to people when they
		first see them.
	</remark>

	<para>
		The <function>to_i2c_driver</function> macro is defined in
		<filename>include/linux/i2c.h</filename> as:

<programlisting>
#define to_i2c_driver(d) container_of(d, struct i2c_driver, driver)
</programlisting>

But what does the <function>container_of</function> macro really do?
This macro is defined as:
<programlisting>
#define container_of(ptr, type, member) ({			\
	const typeof( ((type *)0)-&gt;member ) *__mptr = (ptr);	\
	(type *)( (char *)__mptr - offsetof(type,member) );})
</programlisting>
</para>

<para>
To help understand this, here are the steps of what the C preprocessor
does when it compiles this code.  In the
<filename>include/linux/i2c.h</filename> file, the
<function>to_i2c_driver</function> macro is defined
as:
<programlisting>
container_of(d, struct i2c_driver, driver)
</programlisting>  
and is used in code as:
<programlisting>
i2c_drv = to_i2c_driver(drv)
</programlisting>
where drv is a pointer to a struct device_driver.
</para>

<para>
Replacing the above code with the first macro expansion produces:
<programlisting>
i2c_drv = container_of(drv, struct i2c_driver, driver);
</programlisting>
Then the next level of expansion creates:
<programlisting>
i2c_drv = ({
	const typeof( ((struct i2c_driver *)0)-&gt;driver) *__mptr = drv;
	(struct i2c_driver *)( (char *)__mptr - offsetof(struct i2c_driver, driver)); })
</programlisting>
</para>

<para>
To simplify this, remember that <parameter>driver</parameter> is a
variable within the <function>i2c_driver</function> function.  The first
line of the macro sets up a pointer that points to the <type>struct
device_driver</type> passed to the code.  The second line of the macro
subtracts the location of the offset that the <type>struct
device_driver</type> lives in memory from the pointer that was passed in,
resulting in the real pointer to the <type>struct i2c_driver</type>.
</para>

<para>
To show this using real numbers, imagine that the <type>struct
i2c_driver</type> is
defined as:
<programlisting>
struct i2c_driver {
	struct name[32];
	struct device_driver driver;
};
</programlisting>
In this structure, the location of the <parameter>driver</parameter>
variable will usually be 32 bytes into the structure, depending on
the packing rules of the compiler at the time, and the architecture it
is being compiled for.

<!--  Bibliography reference 
For more information on how to see where variables are located in
structures, see "Writing Portable Device Drivers" in the Embedded
Journal issue 9 at http://www.linuxjournal.com/article.php?sid=5783
-->

So if the <parameter>drv</parameter> pointer is at memory location
<literal>0xC0101020</literal> then the <parameter>__mptr</parameter>
variable will be assigned that location in the first line of the macro.
Then the offset of the driver variable will be subtracted from this
address, giving us the value <literal>0xC0101000</literal> which would
be assigned to the variable on the left side of the original assignment,
i2c_drv.
</para>

<para>
Note, in order to do this kind of pointer manipulation, the code has to
know the type of pointer that is being passed to it.  The driver core
will only pass in the type of driver structure that is registered with
it, so this type of manipulation is safe.  This also prevents other
parts of the kernel from modifying the unique fields of the structure
that is used to control the subsystem's code.
</para>

<para>
Also, since the pointer passed to any <function>container_of</function>
has already been validated (preferably with a check to determine that is
it not equal to <literal>NULL</literal>), the resulting pointer from the
<function>container_of</function> conversion does not have to also be
checked against <literal>NULL</literal>, as it will never be set to that
value.
</para>
</sect3>
</sect2>

<sect2>
<title>
Bus Hotplug
</title>

<para>
The hotplug variable is a pointer to a function that will be called by the
driver core when a new device is added to the kernel or removed from the
kernel for this specific bus.  When it is called, the driver core is
about to call the <filename>/sbin/hotplug</filename> program with
information about a device.  This allows the bus to create any bus
and device specific environment variables that it might want to pass to
userspace that would help describe the device.
</para>

<para>
This hotplug function is defined as:
<programlisting>
int (*hotplug) (struct device *dev, char **envp,
                int num_envp, char *buffer, int buffer_size);
</programlisting>
The <parameter>dev</parameter> parameter is a pointer to the device that
is being added or removed from the system.  The
<parameter>envp</parameter> parameter is a pointer to an array of
pointers that define the environment variable strings that will be
passed to the user, and the <parameter>num_envp</parameter> parameter
contains the size of the <parameter>envp</parameter> array.  The
<parameter>buffer</parameter> parameter is a pointer to a big buffer
that holds the environment variables, and the
<parameter>buffer_size</parameter> parameter is the size in bytes that 
<parameter>buffer</parameter> points to.
</para>

<para>
An example of how to implement a hotplug function call, can be seen in
the following code from i2c-core.c:
<programlisting>
static int i2c_hotplug (struct device *dev, char **envp, int num_envp,
			char *buffer, int buffer_size)
{
	struct i2c_client *i2c_dev;
	char *scratch;
	int i = 0;
	int length = 0;

	if (!dev)
		return -ENODEV;

	i2c_dev = to_i2c_client(dev);
	
	scratch = buffer;

	envp [i++] = scratch;
	length += snprintf (scratch, buffer_size - length,
			    "ADDRESS=%d", i2c_dev-&gt;address);
	if ((buffer_size - length &lt;= 0) || (i &gt;= num_envp))
		return -ENOMEM;
	++length;
	scratch += length;

	envp [i++] = NULL;

	return 0;
}
</programlisting>
In this function, the struct device pointer is converted into a struct
i2c_client pointer with the function to_i2c_client.  Then an environment
variable with the name of ADDRESS and the value of the address of the
i2c device is created.  This envid then a
environment variable ADDRESS is set to the address of the i2c device.
When creating the environment variable string, the buffer size, and the
number of available variables is checked to make sure the function does
not overflow any memory.  Then, the last environment variable is set to
NULL, to indicate that there are no more variables, and a 0 is returned
for success.
</para>

<remark>
Remaining bus fields and function not mentioned:
.add is never used.
get_bus() is only used internally.
put_bus() is only used internally.
find_bus() is only used internally.
bus_for_each_dev() is starting to be used, but pretty complicated.
bus_for_each_drv() is not used by anyone.
BUS_ATTR() is not used by anyone.
bus_create_file() is not used by anyone.
bus_remove_file() is not used by anyone.
</remark>

</sect2>

</sect1>

<sect1>
<title>
Devices
</title>

<para>
All devices in the kernel are created by the specific bus the device is
on, and then registered with the driver core.  The struct device
structure is embedded within the bus specific structure, to allow the
driver core to manage the device.  An example of this is the i2c_client
structure that the i2c core uses to manage i2c devices:
<programlisting>
struct i2c_client {
	int id;
	unsigned int flags;
	unsigned int addr;
	struct i2c_adapter *adapter;
	struct i2c_driver *driver;
	int usage_count;
	struct device dev;
};
#define to_i2c_client(d) container_of(d, struct i2c_client, dev)
</programlisting>
</para>

<sect2>
<title>
Registering and Unregistering a Device
</title>

<para>
When a device has been created by the bus specific core, it should be
registered with the driver core, but first the following fields in the
struct device must be set up:
</para>

<variablelist>

<varlistentry>
<term>
<literal>
struct device *parent;
</literal>
</term>
<listitem>
<para>
This variable must point to either the parent device of this device, or
the parent device controller of this device.  This is to place the
device in the proper location within the global driver tree in the
kernel.
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>
<literal>
struct bus_type *bus;
</literal>
</term>
<listitem>
<para>
This variable must point to the bus_type structure for the bus that this
device is on.
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>
<literal>
struct device_driver *driver;
</literal>
</term>
<listitem>
<para>
This variable is usually set to NULL, so that the driver core will later
match it up with a driver that will accept this device.  However, if the
driver for this device is known at the time it is registered, this
pointer can be set.  If it is set, the driver core will not try to match
this device up with any other driver.
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>
<literal>
char bus_id[BUS_ID_SIZE];
</literal>
</term>
<listitem>
<para>
This variable is a string representation of how the bus refers to this
device in a unique way.  This value must be unique for the parent
device, as this is the name the driver core uses to represent the device
directory in sysfs.
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>
<literal>
char name[DEVICE_NAME_SIZE];
</literal>
</term>
<listitem>
<para>
This variable is the name of the device.  It can be found in the name
file within the sysfs directory of this device.
</para>
</listitem>
</varlistentry>
</variablelist>

<para>
After the driver structure is initialized, it can be registered with the
driver core by calling <function>driver_register</function>.  An example
of initializing the driver structure, and then registering the driver
can be seen in the following code from
<filename>drivers/usb/serial/usb-serial.c</filename>:
<programlisting>
/* register all of the individual ports with the driver core */
for (i = 0; i &lt; num_ports; ++i) {
	port = &amp;serial-&gt;port[i];
	port-&gt;dev.parent = &amp;serial-&gt;dev-&gt;dev;
	port-&gt;dev.driver = NULL;
	port-&gt;dev.bus = &amp;usb_serial_bus_type;

	snprintf(&amp;port-&gt;dev.bus_id[0], sizeof(port-&gt;dev.bus_id),
		"ttyUSB%d", port-&gt;number);
	snprintf(&amp;port-&gt;dev.name[0], sizeof(port-&gt;dev.name),
		"usb serial port %d", port-&gt;number);
	device_register(&amp;port-&gt;dev);
}
</programlisting>
</para>

<para>
To unregister a device when it is gone from the system, the
<function>device_unregister</function> should be called.  Again,
<filename>drivers/usb/serial/usb-serial.c</filename> does this:
<programlisting>
for (i = 0; i &lt; serial-&gt;num_ports; ++i)
	device_unregister(&amp;serial-&gt;port[i].dev);
</programlisting>
</para>

</sect2>

<sect2>
<title>
Device specific files
</title>

<para>
One of the nice features of the driver model, is it provides a very
simple way for drivers to create files in sysfs.  Using sysfs is the
preferred place for drivers to provide files that users might want to
read or write data to, instead of the /proc filesystem.  All files in
sysfs should only be for one value...
<remark>
hm, I need to put some background in about sysfs, and it's "rules",
should it be before this, or down below in the "what drives it all"
section?
</remark>
</para>

<para>
To create a device specific file, meaning it will show up in the sysfs
tree where ever a device of this type is, the
<literal>DEVICE_ATTR</literal> macro is used.  This macro creates a
device_attribute structure and initializes it with some data based on
the values passed to it.  The DEVICE_ATTR macro is defined as:
<programlisting>
#define DEVICE_ATTR(_name,_mode,_show,_store)			\
struct device_attribute dev_attr_##_name = {			\
	.attr	= {.name = __stringify(_name), .mode = _mode },	\
	.show	= _show,					\
	.store	= _store,					\
};
</programlisting>
The arguments to the DEVICE_ATTR macro are:
<variablelist>

<varlistentry>
<term>
<literal>
_name
</literal>
</term>
<listitem>
<para>
This defines both the name of the file that will be created in sysfs,
and is part of the variable name that describes this whole attribute.
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>
<literal>
_mode
</literal>
</term>
<listitem>
<para>
This is the file access mode that the file will be created with.  Use
the standard access macros to specify the proper value.
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>
<literal>
_show
</literal>
</term>
<listitem>
<para>
A pointer to a function that will be called when the file is read from.
This function must have the following return value and paramaters:
<programlisting>
	ssize_t show (struct device *dev, char *buf);
</programlisting>
This variable does not have to be set, if the file is not to be read
from.
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>
<literal>
_store
</literal>
</term>
<listitem>
<para>
A pointer to a function that will be called when the file is written to.
This function must have the following return value, and paramaters:
<programlisting>
	ssize_t store (struct device *dev, const char *buf, size_t count);
</programlisting>
This variable does not have to be set, if the file is not to be written
to.
</para>
</listitem>
</varlistentry>
</variablelist>

</para>

<para>
An example of how to use the <literal>DEVICE_ATTR</literal> macro to
create a sysfs file that will show the id value of an i2c device is the
following:
<programlisting>
static ssize_t show_id(struct device *dev, char *buffer)
{
	struct i2c_device *idev;

	idev = to_i2c_device(dev);
	return sprintf(buffer, "%d", idev-&gt;id);
}
DEVICE_ATTR(id, S_IRUGO, show_id, NULL);
</programlisting>
</para>

<para>
This instance of the <literal>DEVICE_ATTR</literal> macro will be
expanded to the following code:
<programlisting>
struct device_attribute dev_attr_id = {
	.attr	= {
		.name = "id",
		.mode = S_IRUGO,
	},
	.show	= show_id,
	.store	= NULL,
};
</programlisting>
Then, after the i2c device has been registered with the driver core,
during the initialization code, the following call to
<function>device_create_file</function> will create the file in the
device specific sysfs directory:
<programlisting>
	device_create_file(&amp;i2c_dev.dev, &amp;dev_attr_id);
</programlisting>
</para>

<para>
The file can be later removed at any time with a call to
<function>device_remove_file</function> like so:
<programlisting>
	device_remove_file(&amp;i2c_dev.dev, &amp;dev_attr_id);
</programlisting>
However, this call does not have to be made.  When the device is removed
from the system with a call to <function>device_unregister</function>,
all files that have been created for this device with
<function>device_create_file</function> will be automatically deleted
from sysfs by the driver core, thereby making the driver author's life
much easier.
</para>

<remark>
Functions not mentioned:
dev_get_drvdata() - usually overridden by the bus type
dev_set_drvdata() - usually overridden by the bus type

device_initialize()/device_add() - tricky to do, if you want to use the
device a bit, before it is registered with the driver core.  Don't
really know if I want to go into this...
</remark>

</sect2>

<sect2>
<title>
Device Drivers
</title>

</sect2>

<para>
struct device_driver
</para>

<para>
.name
</para>

<para>
.bus
</para>

<para>
.probe
</para>

<para>
.remove
</para>

<para>
.shutdown
</para>

<para>
.suspend
</para>

<para>
.resume
</para>

<para>
driver_register()
</para>

<para>
driver_unregister()
</para>

<para>
DRIVER_ATTR()
</para>

<para>
driver_create_file()
</para>

<para>
driver_remove_file()
</para>

</sect1>


<sect1>
<title>
Classes
</title>

<para>
	After a <literal>struct device</literal> is registered in the kernel to
	its proper bus, the driver that is bound to the device usually registers
	with a kernel class to allow a user to interact with the device.  These
	classes usually consist of a number of different types of devices,
	bundling them up so that the user can access them in the same way.  For
	example, the input class code in the kernel provides a single way to get
	all of the mouse data from all mice that are currently plugged in.
	Serial mice, PS/2 mice, and USB mice all look to the user as just a
	normal mouse, alleviating them from having to talk to three different
	devices in three different ways.
</para>

<sect2>
	<title>Registering and Unregistering a Class</title>

	<para>
		Classes in the kernel are defined with a simple
		<literal>struct class</literal> struture.  To create a class
		structure, only the <literal>name</literal> field in the
		<literal>struct class</literal> variable needs to be defined in
		order for it to be a valid class.  This can be done with
		the following code:
		<programlisting>
<![CDATA[
	static struct class i2c_class = {
		.name = "i2c",
	};
]]>
		</programlisting>
	</para>

	<para>
		After the class structure is defined it can be registered with
		the driver core by calling the
		<function>class_register</function> function:
		<programlisting>
<![CDATA[
	if (class_register(&i2c_class) != 0)
		printk(KERN_ERR "i2c class failed to register properly\n");
]]>
		</programlisting>
	</para>

	<para>
		Later, when the class is being unloaded, the
		<function>class_unregister</function> function should be called:
		<programlisting>
<![CDATA[
	class_unregister(&i2c_class);
]]>
		</programlisting>
	</para>
	
</sect2>

<sect2>
	<title>Class Hotplug events</title>

	<remark>
		bah, just refer to above for the bus stuff...
	</remark>
	<para>
		Whenever a class device is added or removed from a specific
		class (see below for how to do that), the driver core generates
		a hotplug event and sends it to userspace.  This allows user
		programs to keep track of the different devices added and
		removed in the kernel.  All classes have the ability to add data
		to the hotplug event that is sent to the user.  To do this, a
		<function>hotplug</function> function callback is present in the
		<literal>struct class</literal> structure.  This function call
		is defined as:
		<programlisting>
<![CDATA[
int (*hotplug)(struct class_device *dev, char **envp,
               int num_envp, char *buffer, int buffer_size);
]]>
		</programlisting>
	</para>
	<para>
		Hotplug events consist of a number of default environment
		variables, and this callback function allows the class to add
		any class specific environment variable that it wishes to, to
		the event.  For example, if the i2c class wanted to add a
		environment variable that stated the i2c class device's address
		that was just added or removed, it could do the following:
		<programlisting>
<![CDATA[
static int i2c_hotplug (struct class_device *dev, char **envp,
			int num_envp, char *buffer, int buffer_size)
{
	struct i2c_device *i2c_dev = to_i2c_class_device(dev);
	char *scratch = buffer;
	int i = 0;
	int length = 0;

	envp [i++] = scratch;
	length += snprintf (scratch, buffer_size - length,
			    "I2C_ADDRESS=%04x", i2c_dev->address);
        if ((buffer_size - length <= 0) || (i >= num_envp))
                return -ENOMEM;
        ++length;
        envp [i++] = 0;

	return 0;
}
]]>
		</programlisting>
		The <function>i2c_hotplug</function> function converts the
		<literal>struct class_device</literal> variable that is passed
		to it, into a i2c_device pointer.  Then a single environment
		variable is copied into the buffer that contains the name
		<literal>I2C_ADDRESS</literal> and the value is the i2c device's
		address.  The function checks to make sure that we did not
		overwrite the end of the buffer that was passed to us, and
		creates a pointer in the <literal>envp</literal> array that
		points to the string we just created.
	</para>
	<para>
		Note, the hotplug class callback does not differ if the device
		is added or removed from the system.  This is because the same
		information should be sent to the user in both situations.  For
		more information on the different kernel hotplug events and
		variables, please refer to the documentation written by the
		Linux Hotplug project at http://linux-hotplug.sf.net/
	</para>
</sect2>

<sect2>
	<title>Class devices</title>

<para>
	struct class_device
	.class
	.dev
	.class_data
	.class_id
	class_get_devdata()
	class_set_devdata()
	class_device_register()
	class_device_unregister()
</para>
</sect2>
<sect2>
	<title>Files for classes</title>

	<para>
		Just like creating device files, the driver core makes it very
		easy to create class or class device specific files.  To define
		a file that will show up in the class direcory in sysfs, use the
		<function>CLASS_ATTR</function> macro.  To define a file that
		will show up in a class device directory, use the
		<function>CLASS_DEVICE_ATTR</function> macro.  Both of these
		macros have the same paramaters as the
		<function>DEVICE_ATTR</function> macro described above do, with
		the exception that the <function>_show</function> and
		<function>_store</function> function pointers expect slightly
		different functions.
	</para>

	<para>
		For the <function>CLASS_ATTR</function> macro, the
		<function>_show</function> and <function>_store</function>
		function must look like the following:
		<programlisting>
	ssize_t show (struct class *class, char *buf);
	ssize_t store (struct class *class, const char *buf, size_t count);
		</programlisting>
		The first parameter differs from the
		<function>DEVICE_ATTR</function> functions in that it receives a
		pointer to a <literal>struct class</literal>.
	</para>
	<para>
		For the <function>CLASS_DEVICE_ATTR</function> macro, the
		<function>_show</function> and <function>_store</function>
		function must look like the following:
		<programlisting>
	ssize_t show (struct class_device *class_dev, char *buf);
	ssize_t store (struct class_device *class_dev, const char *buf, size_t count);
		</programlisting>
	</para>

	<para>
		After the class or class device variables have been registered
		with the driver core, a file can be created with a call to
		<function>class_create_file</function> for a class file, or a
		call to <function>class_device_create_file</function> for a
		class device file.  Like device files, it is not necessary to
		manually remove a class or class device file, as the driver core
		will clean them up automatically when the class or class device
		is unregistered from the system.  However if you want to
		manually remove them, the functions
		<function>class_remove_file</function> and
		<function>class_device_remove_file</function> should be used.
	</para>

	<remark>
		Do I need an example here of using these?  They are so close to
		the above described and exampled device files that I feel it is
		not really needed.
	</remark>

</sect2>

<para>
	struct class_interface
	.class
	.add()
	.remove()
	class_interface_register()
	class_interface_unregister()
	
</para>

</sect1>

<sect1>
<title>
How it all works
</title>


<para>
To better understand what the driver model does, let us walk through the
steps of a device's lifecycle within the kernel.  As an example, we will
look at a PCI device.  The figure below shows how the PCI Core, driver
core, and individual PCI drivers interact when a device is initialized
in the kernel.
</para>

<figure>
<title>Device Creation Process</title>
<graphic fileref="figures/ldsp_0103.png"/>
</figure>

<remark>
So with the above diagram, should I continue on to explain the steps
like I am doing?
</remark>

<para>
When the PCI core is initialized by the kernel, it registers a
<literal>struct bus_type *</literal> with the kernel:
<programlisting>
static int __init pci_driver_init(void)
{
	return bus_register(&amp;pci_bus_type);
}
</programlisting>
This <literal>pci_bus_type</literal> variable is declared as:
<programlisting>
struct bus_type pci_bus_type = {
	.name		= "pci",
	.match		= pci_bus_match,
	.hotplug	= pci_hotplug,
};
</programlisting>
When <function>bus_register</function> is called, the driver core adds
the <literal>pci_bus_type</literal> to the internal list of busses, and
creates the following sysfs directories:
<screen>
/sys/bus/pci
/sys/bus/pci/devices
/sys/bus/pci/drivers
</screen>
</para>

<para>
After this, the PCI core, with help from the architecture specific code
that actually talks to the PCI bus, starts probing the PCI address
space, looking for all PCI devices.  When a PCI device is found, the PCI
core creates a new variable in memory of type <literal>struct pci_dev</literal>.
A portion of the <literal>struct pci_dev</literal> structure looks like
the following (this structure will be covered in detail in the PCI
chapter):
<programlisting>
struct pci_dev {
	...

	unsigned int	devfn;
	unsigned short	vendor;
	unsigned short	device;
	unsigned short	subsystem_vendor;
	unsigned short	subsystem_device;
	unsigned int	class;

	...

	struct pci_driver *driver;
	u64		dma_mask;
	struct device	dev;

	...
};
</programlisting>

The bus specific fields of this PCI device are initialized by the PCI
core (the devfn, vendor, device, and other fields), and the
<literal>struct device</literal> variable's <literal>parent</literal>
variable is set to the PCI bus device that this PCI device lives on.
The <literal>bus</literal> variable is set to point at the 
<literal>pci_bus_type</literal> structure.  Then the
<literal>name</literal> and <literal>bus_id</literal> variables are set
depending on the name and id that is read from the PCI device.
</para>

<para>
After the PCI device structure is initialize, the device is registered
with the driver core with a call to:
<programlisting>
device_register(&amp;dev-&gt;dev);
</programlisting>
Within the <function>device_register</function> function, the driver
core initializes a number of the device's fields, and then adds the
device to the list of devices that are held by the device's parent.
This is done so that all devices can be walked in the proper order,
always knowing where in the heirachy of devices each one lives.
</para>

<para>
The device is then added to the bus specific list list of all devices,
in this example, the <literal>pci_bus_type</literal> list.  Then the
list of all drivers that are registered with the bus is walked, and
the <literal>match</literal> function of the bus is called for every
driver, with this device.  For the <literal>pci_bus_type</literal> bus,
the match function is specified as the
<function>pci_bus_match</function> function.
</para>

<para>
probe
</para>

<para>
pci_device_probe
</para>

<para>
driver probe
</para>

<para>
driver initializes device
</para>

<para>
core creates sysfs links
</para>

<para>
hotplug
</para>

<para>
pci_hotplug
</para>

<para>
device class initialization
</para>

<remark>
Show device removal?
</remark>

<remark>
Show driver add/remove?  Not really as interesting, but might be good
for completeness.
</remark>

</sect1>

<sect1>
<title>
What drives it all
</title>

<sect2>
<title>
kobject
</title>

<para>
basic reference counting structure
</para>

<para>
struct kobject
</para>

<para>
.name
</para>

<para>
kobject_get()
</para>

<para>
kobject_put() - last one, structure is deleted.
</para>

<sect3>
<title>initializing and destroying</title>

<para>
kobject_init()
</para>

<para>
kobject_cleanup()
</para>

<para>
kobject_add()
</para>

<para>
kobject_delete()
</para>

<para>
kobject_register()
</para>

<para>
kobject_unregister()
</para>

</sect3>

<para>
kobj_type
</para>

<para>
.release
</para>

</sect2>

<sect2>
<title>
kset
</title>

<para>
set of kobjects belonging to a specific subsystem
</para>

<para>
struct kset
</para>

<para>
.subsys
</para>

<para>
.ktype
</para>

</sect2>

<sect2>
<title>
subsystem
</title>

<para>
struct subsystem
</para>

<para>
.kset
</para>

<para>
.rwsem
</para>

<para>
decl_subsys()
</para>

</sect2>

</sect1>

<sect1>
	<title>Quick Reference</title>

	<para>
		This section provides a reference for the concepts introduced in
		this chapter.
	</para>

<variablelist>

<varlistentry>
	<term>
		<literal>
			#include &lt;linux/device.h&gt;
		</literal>
	</term>
	<listitem>
		<para>
			This header file contains all of the driver model
			structures and function prototypes.
		</para>
	</listitem>
</varlistentry>

<varlistentry>
	<term>
		<function>
			int bus_register(struct bus_type *bus);
		</function>
	</term>
	<term>
		<function>
			void bus_unregister(struct bus_type *bus);
		</function>
	</term>
	<listitem>
		<para>
			Functions used to register and unregister a bus.
		</para>
	</listitem>
</varlistentry>

<varlistentry>
	<term>
		<function>
			BUS_ATTR(_name,_mode,_show,_store)
		</function>
	</term>
	<listitem>
		<para>
			Macro used to create a 
			<literal>struct bus_attribute</literal> 
			which is used to pass to
			<function>bus_create_file</function> and
			<function>bus_remove_file</function>.
		</para>
	</listitem>
</varlistentry>

<varlistentry>
	<term>
		<function>
			int bus_create_file(struct class *bus, struct bus_attribute *attr);
		</function>
	</term>
	<term>
		<function>
			void bus_remove_file(struct class *bus, struct bus_attribute *attr);
		</function>
	</term>
	<listitem>
		<para>
			Functions used to create and remove bus specific files
			from sysfs.
		</para>
	</listitem>
</varlistentry>

<varlistentry>
	<term>
		<function>
			int class_register(struct class *class);
		</function>
	</term>
	<term>
		<function>
			void class_unregister(struct class *class);
		</function>
	</term>
	<listitem>
		<para>
			Functions used to register and unregister a class.
		</para>
	</listitem>
</varlistentry>

<varlistentry>
	<term>
		<function>
			CLASS_ATTR(_name,_mode,_show,_store)
		</function>
	</term>
	<listitem>
		<para>
			Macro used to create a 
			<literal>struct class_attribute</literal> 
			which is used to pass to
			<function>class_create_file</function> and
			<function>class_remove_file</function>.
		</para>
	</listitem>
</varlistentry>

<varlistentry>
	<term>
		<function>
			int class_create_file(struct class *class, struct class_attribute *attr);
		</function>
	</term>
	<term>
		<function>
			void class_remove_file(struct class *class, struct class_attribute *attr);
		</function>
	</term>
	<listitem>
		<para>
			Functions used to create and remove class specific files
			from sysfs.
		</para>
	</listitem>
</varlistentry>

<varlistentry>
	<term>
		<function>
			int class_device_register(struct class_device *dev);
		</function>
	</term>
	<term>
		<function>
			void class_device_unregister(struct class_device *dev);
		</function>
	</term>
	<listitem>
		<para>
			Functions used to register and unregister a class device.
		</para>
	</listitem>
</varlistentry>

<varlistentry>
	<term>
		<function>
			void *class_get_devdata (struct class_device *dev);
		</function>
	</term>
	<term>
		<function>
			void class_set_devdata (struct class_device *dev, void *data);
		</function>
	</term>
	<listitem>
		<para>
			Functions used to get and set class device specific data.
		</para>
	</listitem>
</varlistentry>

<varlistentry>
	<term>
		<function>
			CLASS_DEVICE_ATTR(_name,_mode,_show,_store)
		</function>
	</term>
	<listitem>
		<para>
			Macro used to create a 
			<literal>struct class_device_attribute</literal> 
			which is used to pass to
			<function>class_device_create_file</function> and
			<function>class_device_remove_file</function>.
		</para>
	</listitem>
</varlistentry>

<varlistentry>
	<term>
		<function>
			int class_device_create_file(struct class_device *dev, struct class_device_attribute *attr);
		</function>
	</term>
	<term>
		<function>
			void class_device_remove_file(struct class_device *dev, struct class_device_attribute *attr);
		</function>
	</term>
	<listitem>
		<para>
			Functions used to create and remove class device
			specific files from sysfs.
		</para>
	</listitem>
</varlistentry>

<varlistentry>
	<term>
		<function>
			int class_interface_register(struct class_interface *class_intf);
		</function>
	</term>
	<term>
		<function>
			void class_interface_unregister(struct class_interface *class_intf);
		</function>
	</term>
	<listitem>
		<para>
			Functions used to register and unregister a class device.
		</para>
	</listitem>
</varlistentry>


</variablelist>


</sect1>
</chapter>

<!-- vim: set ai tw=80 : -->
