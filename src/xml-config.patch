---
 arch/i386/Kconfig        |    4 
 scripts/kconfig/Makefile |    2 
 scripts/kconfig/conf.c   |    1 
 scripts/kconfig/expr.c   |    6 -
 scripts/kconfig/lkc.h    |    1 
 scripts/kconfig/zconf.y  |  199 +++++++++++++++++++++++++++++++++++++++++++++++
 6 files changed, 209 insertions(+), 4 deletions(-)

--- lkn-2.6.14-rc5.orig/scripts/kconfig/Makefile
+++ lkn-2.6.14-rc5/scripts/kconfig/Makefile
@@ -221,7 +221,7 @@ $(obj)/lkc_defs.h: $(src)/lkc_proto.h
 # The following requires flex/bison
 # By default we use the _shipped versions, uncomment the following line if
 # you are modifying the flex/bison src.
-# LKC_GENPARSER := 1
+LKC_GENPARSER := 1
 
 ifdef LKC_GENPARSER
 
--- lkn-2.6.14-rc5.orig/scripts/kconfig/conf.c
+++ lkn-2.6.14-rc5/scripts/kconfig/conf.c
@@ -534,6 +534,7 @@ int main(int ac, char **av)
 	}
 	conf_parse(name);
 	//zconfdump(stdout);
+	gregkh_confdump(stdout);
 	switch (input_mode) {
 	case set_default:
 		if (!defconfig_file)
--- lkn-2.6.14-rc5.orig/scripts/kconfig/expr.c
+++ lkn-2.6.14-rc5/scripts/kconfig/expr.c
@@ -1026,7 +1026,8 @@ void expr_print(struct expr *e, void (*f
 		if (e->left.sym->name)
 			fn(data, e->left.sym->name);
 		else
-			fn(data, "<choice>");
+//			fn(data, "<choice>");
+			fn(data, "</literal><emphasis>choice</emphasis><literal>");
 		break;
 	case E_NOT:
 		fn(data, "!");
@@ -1049,7 +1050,8 @@ void expr_print(struct expr *e, void (*f
 		break;
 	case E_AND:
 		expr_print(e->left.expr, fn, data, E_AND);
-		fn(data, " && ");
+//		fn(data, " && ");
+		fn(data, " and ");
 		expr_print(e->right.expr, fn, data, E_AND);
 		break;
 	case E_CHOICE:
--- lkn-2.6.14-rc5.orig/scripts/kconfig/zconf.y
+++ lkn-2.6.14-rc5/scripts/kconfig/zconf.y
@@ -682,6 +682,205 @@ void zconfdump(FILE *out)
 	}
 }
 
+static void gkh_print_string(FILE *out, int len, const char *str)
+{
+	while (len) {
+		if (*str == '<')
+			fputs("&lt;", out);
+		else if (*str == '>')
+			fputs("&gt;", out);
+		else if (*str == '&')
+			fputs("&amp;", out);
+		else putc(*str, out);
+		--len;
+		++str;
+	}
+}
+
+static void gkh_print_quoted_string(FILE *out, const char *str)
+{
+	const char *p;
+	int len;
+
+	putc('"', out);
+	while ((p = strchr(str, '"'))) {
+		len = p - str;
+		if (len)
+			gkh_print_string(out, len, str);
+//			fprintf(out, "%.*s", len, str);
+		fputs("\\\"", out);
+		str = p + 1;
+	}
+	//fputs(str, out);
+	gkh_print_string(out, strlen(str), str);
+	putc('"', out);
+}
+
+static void gkh_output_help(FILE *out, char *string)
+{
+	char *current = string;
+
+	fprintf(out, "\t");
+	while (*current) {
+		if ((current[0] == '\n') && (current[1] == '\n')) {
+			fprintf(out, "\n\t</para>\n\n\t<para>\n\t");
+			current++;
+		} else if (*current == '\n')
+			fprintf(out, "\n\t");
+		else if ((*current == '<') || (*current == '>'))
+			;
+		else if (*current == '&')
+			fprintf(out, "and");
+		else
+			fprintf(out, "%c", *current);
+		current++;
+	}
+	fprintf(out, "\n");
+}
+
+void gkh_print_symbol(FILE *out, struct menu *menu)
+{
+	struct symbol *sym = menu->sym;
+	struct property *prop;
+	int entrybody_start = 0;
+
+	fprintf(out, "<nutentry>\n");
+	if (sym_is_choice(sym))
+		fprintf(out, "choice\n");
+	else
+		fprintf(out, "\t<term>%s</term>\n", sym->name);
+
+	for (prop = sym->prop; prop; prop = prop->next) {
+		if (prop->menu != menu)
+			continue;
+		switch (prop->type) {
+		case P_PROMPT:
+			fprintf(out, "<nutsynopsis>\n\t");
+			gkh_print_quoted_string(out, prop->text);
+			fprintf(out, "\n</nutsynopsis>\n");
+			fprintf(out, "<nutentrybody>\n");
+			entrybody_start = 1;
+			if (!expr_is_yes(prop->visible.expr)) {
+				fprintf(out, "\t<para>\n\tdepends on\n\t<literal>");
+				expr_fprint(prop->visible.expr, out);
+				fprintf(out, "</literal>\n\t</para>\n\n");
+			}
+			break;
+		case P_DEFAULT:
+			fprintf(out, "\t<para>\n\tdefault value\n\t<literal>");
+			expr_fprint(prop->expr, out);
+			if (!expr_is_yes(prop->visible.expr)) {
+				fputs(" if ", out);
+				expr_fprint(prop->visible.expr, out);
+			}
+			fprintf(out, "</literal>\n\t</para>\n\n");
+			break;
+		case P_CHOICE:
+			//fputs("  #choice value\n", out);
+			break;
+		default:
+			fprintf(out, "  unknown prop %d!\n", prop->type);
+			break;
+		}
+	}
+
+	fprintf(out, "\t<para>\n\ttype\n\t<literal>");
+	switch (sym->type) {
+	case S_BOOLEAN:
+		fputs("boolean", out);
+		break;
+	case S_TRISTATE:
+		fputs("tristate", out);
+		break;
+	case S_STRING:
+		fputs("string", out);
+		break;
+	case S_INT:
+		fputs("integer", out);
+		break;
+	case S_HEX:
+		fputs("hex", out);
+		break;
+	default:
+		fputs("???", out);
+		break;
+	}
+	fprintf(out, "</literal>\n\t</para>\n\n");
+
+	if (!entrybody_start)
+		fprintf(out, "<nutentrybody>\n");
+
+	if (sym->help) {
+		int len = strlen(sym->help);
+		while (sym->help[--len] == '\n')
+			sym->help[len] = 0;
+		fprintf(out, "\t<para>\n");
+		// convert help paragraphs to xml paragraphs
+		gkh_output_help(out, sym->help);
+		fprintf(out, "\t</para>\n\n");
+	}
+
+	fprintf(out, "</nutentrybody>\n");
+	fprintf(out, "</nutentry>\n\n");
+}
+
+void gregkh_confdump(FILE *out)
+{
+	struct property *prop;
+	struct symbol *sym;
+	struct menu *menu;
+	int depth=2;
+
+	menu = rootmenu.list;
+	while (menu) {
+		if ((sym = menu->sym))
+			gkh_print_symbol(out, menu);
+		else if ((prop = menu->prompt)) {
+			switch (prop->type) {
+			case P_COMMENT:
+//				fputs("\ncomment ", out);
+//				gkh_print_quoted_string(out, prop->text);
+//				fputs("\n", out);
+				/* I don't think we want to print these at all... */
+				goto cont;
+				break;
+			case P_MENU:
+//				fputs("\nmenu ", out);
+				fprintf(out, "\n<sect%d>\n\t<title>", depth);
+				gkh_print_quoted_string(out, prop->text);
+				fputs("</title>\n<nutlist>\n", out);
+				fputs("\n", out);
+				++depth;
+				break;
+			default:
+				;
+			}
+			if (!expr_is_yes(prop->visible.expr)) {
+				fprintf(out, "<para>\n\tdepends on\n\t<literal>");
+				expr_fprint(prop->visible.expr, out);
+				fprintf(out, "</literal>\n\t</para>\n\n");
+			}
+			fputs("\n", out);
+		}
+cont:
+		if (menu->list)
+			menu = menu->list;
+		else if (menu->next)
+			menu = menu->next;
+		else while ((menu = menu->parent)) {
+			if (menu->prompt && menu->prompt->type == P_MENU) {
+//				fputs("\nendmenu\n", out);
+				--depth;
+				fprintf(out, "\n</nutlist>\n</sect%d>\n\n", depth);
+			}
+			if (menu->next) {
+				menu = menu->next;
+				break;
+			}
+		}
+	}
+}
+
 #include "lex.zconf.c"
 #include "util.c"
 #include "confdata.c"
--- lkn-2.6.14-rc5.orig/scripts/kconfig/lkc.h
+++ lkn-2.6.14-rc5/scripts/kconfig/lkc.h
@@ -39,6 +39,7 @@ extern "C" {
 
 int zconfparse(void);
 void zconfdump(FILE *out);
+void gregkh_confdump(FILE *out);
 
 extern int zconfdebug;
 void zconf_starthelp(void);
--- lkn-2.6.14-rc5.orig/arch/i386/Kconfig
+++ lkn-2.6.14-rc5/arch/i386/Kconfig
@@ -3,7 +3,7 @@
 # see Documentation/kbuild/kconfig-language.txt.
 #
 
-mainmenu "Linux Kernel Configuration"
+menu "Linux Kernel Configuration"
 
 config X86_32
 	bool
@@ -1042,3 +1042,5 @@ config X86_TRAMPOLINE
 	bool
 	depends on X86_SMP || (X86_VOYAGER && SMP)
 	default y
+
+endmenu
