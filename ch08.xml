<chapter id="LKN-configuring">

<title>
Configuring a kernel
</title>

<para>
One of the hardest parts of building your own version of the Linux kernel
is determining exactly which drivers and configuration options are needed
in order for your machine to work properly.  This chapter will walk you
through this process of finding the correct drivers.
</para>

<sect1>
<title>Using a distribution kernel</title>

<para>
One of the easiest ways of determining which modules are necessary, is to
work off of the kernel configuration that comes with your distribution's
kernel package.  It is also much easier to determine which drivers are
needed on a running system, where the proper drivers are already bound to
the hardware.
</para>

<para>
If you do not already have a Linux distribution installed on the machine
that you are building the kernel for, use a LiveCD version of a
distribution.  This allows you to boot Linux on the machine and determine
what kernel configuration options are needed in order to get the hardware
working properly.
</para>

<sect2>
<title>Where is the kernel configuration</title>

<para>
Almost all distributions provide the kernel configuration files as part of
the kernel package.  Read the distribution specific documentation for how
to find these configurations, as it is usually burried somewhere below the
<filename>/usr/src/linux/</filename> directory tree.
</para>

<para>
If the kernel configuration is not easy to find, look in the kernel itself.
Most distribution kernels are build to include the configuration within the
<filename>/proc</filename> filesystem.  To determine if this is true for
your running kernel, do the following:
<screen>
$ <userinput>ls /proc/config.gz</userinput>
/proc/config.gz
</screen>
If the <filename>/proc/config.gz</filename> filename is present, copy this
file to your kernel source directory and uncompress it:
<screen>
$ <userinput>cp /proc/config.gz ~/linux/</userinput>
$ <userinput>cd ~/linux</userinput>
$ <userinput>gzip -dv config.gz</userinput>
config.gz:       74.9% -- replaced with config
</screen>
Then copy this config file into your kernel directory and use it as the
basis of the kernel configuration to build the kernel as described in
chapter <xref linkend="LKN-chapter-building" />.
</para>

<para>
Using this configuration file should always generate a working kernel image
for your machine.  The disadvantage of this kernel image is that you will
have built almost every kernel module and driver that is present in the
kernel source tree.  This is almost never needed for a single machine, so
you can start to turn off different drivers and options that are not
needed.  It is recommended that you only disable options that you are sure
you do not need, as there might be parts of the system that rely on
specific options to be enabled.
</para>

</sect2>

<sect2>
<title>Finding what module is needed</title>

<para>
When using a configuration file that comes from a distribution, it take a
very long time to build due to all of the different drivers being built.
You only want to build the drivers for the hardware that you have, which
will save time on building the kernel, and allows you to build some or all
of the drivers into the kernel itself, possibly saving a bit of memory, and
on some architectures, making for a faster running system.  To do this, you
need to determine which modules are needed to drive your hardware.  We will
walk though two examples of how to find out what driver is needed to
control what piece of hardware.
</para>

<para>
There are many different locations that are useful for determining what
devices is bound to what drivers in a running kernel.  The most important
one is a virtual filesystem called <literal>sysfs</literal>.
<literal>sysfs</literal> should always be mounted at the
<filename>/sys</filename> location in your filesystem by the initialization
scripts of your Linux distribution.  <literal>sysfs</literal> provides a
glimpse into how the different portions of the kernel are hooked together,
with many different symlinks pointing all around the filesystem.
</para>

<para>
In all of the following examples, real <literal>sysfs</literal> paths and
hardware types are shown.  Your machine will be different, but the
locations of where the information will be is in the same place.  Do not be
alarmed if the different file names in <literal>sysfs</literal> are
different from your machine, it is to be expected.
</para>

<sect3>
<title>Need a subsection title here?</title>

<para>
One of the most common, and important, devices in the system is the network
device.  It is imperitive that we figure out which driver is controlling
this device, and enable it in our kernel configuration so that networking
works properly.
</para>

<para>
First, let us work backward from the network connection name to find out
what PCI device is controlling it.  To do this, look at the different
network names:
<screen>
$ <userinput>ls /sys/class/net/</userinput>
eth0  eth1  eth2  lo
</screen>
The device <literal>lo</literal> is the network loopback device, and is not
attached to any real network device.  The devices <literal>eth0</literal>,
<literal>eth1</literal>, and <literal>eth2</literal> are what you should
pay attention to, as they represent "real" network devices.
</para>

<para>
To look further at these network devices, to figure out which one we care
about, use the <literal>ifconfig</literal> utility:
<screen>
$ <userinput>/sbin/ifconfig -a</userinput>
eth0      Link encap:Ethernet  HWaddr 00:12:3F:65:7D:C2  
          inet addr:192.168.0.13  Bcast:192.168.0.255  Mask:255.255.255.0
          UP BROADCAST NOTRAILERS RUNNING MULTICAST  MTU:1500  Metric:1
          RX packets:2720792 errors:0 dropped:0 overruns:0 frame:0
          TX packets:1815488 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:100 
          RX bytes:3103826486 (2960.0 Mb)  TX bytes:371424066 (354.2 Mb)
          Base address:0xdcc0 Memory:dfee0000-dff00000 

eth1      Link encap:UNSPEC  HWaddr 80-65-00-12-7D-C2-3F-00-00-00-00-00-00-00-00-00  
          BROADCAST MULTICAST  MTU:1500  Metric:1
          RX packets:0 errors:0 dropped:0 overruns:0 frame:0
          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:1000 
          RX bytes:0 (0.0 b)  TX bytes:0 (0.0 b)

eth2      Link encap:UNSPEC  HWaddr 00-02-3C-04-11-09-D2-BA-00-00-00-00-00-00-00-00  
          BROADCAST MULTICAST  MTU:1500  Metric:1
          RX packets:0 errors:0 dropped:0 overruns:0 frame:0
          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:1000 
          RX bytes:0 (0.0 b)  TX bytes:0 (0.0 b)

lo        Link encap:Local Loopback  
          inet addr:127.0.0.1  Mask:255.0.0.0
          UP LOOPBACK RUNNING  MTU:16436  Metric:1
          RX packets:60 errors:0 dropped:0 overruns:0 frame:0
          TX packets:60 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:0 
          RX bytes:13409 (13.0 Kb)  TX bytes:13409 (13.0 Kb)
</screen>
From this list, the <literal>eth0</literal> device is the network device
that is active and working, as can be seen by the lines:
<screen>
eth0      Link encap:Ethernet  HWaddr 00:12:3F:65:7D:C2  
          inet addr:192.168.0.13  Bcast:192.168.0.255  Mask:255.255.255.0
</screen>
that show this is a ethernet device, with a valid network address assigned
to it.
</para>

<para>
Now that we have determined that we want to make sure the
<literal>eth0</literal> device will be working in our new kernel, we need
to find which driver is controlling it.  That is simply a matter of walking
the different links in the <literal>sysfs</literal> filesystem.  This can
be done in one line:
<screen>
$ <userinput>basename `readlink /sys/class/net/eth0/device/driver/module`</userinput>
e1000
</screen>
This shows that the module named <literal>e1000</literal> is controlling
the <literal>eth0</literal> network device.
</para>
<para>
Now that we have the module name, we need to find the kernel configuration
option that controlls it.  You can look through the different network
device configuration menus, or you can search the kernel source code
instead to make sure:
<screen>
$ <userinput>cd ~/linux/linux-2.6.17.8</userinput>
$ <userinput>find -type f -name Makefile | xargs grep e1000</userinput>
./drivers/net/Makefile:obj-$(CONFIG_E1000) += e1000/
./drivers/net/e1000/Makefile:obj-$(CONFIG_E1000) += e1000.o
./drivers/net/e1000/Makefile:e1000-objs := e1000_main.o e1000_hw.o e1000_ethtool.o e1000_param.o
</screen>
Note, please replace <literal>e1000</literal> with the name of the module
that you are looking to find.
</para>

<para>
The important thing to be looking for in the output of the above command is
any line that has the term <literal>CONFIG_</literal> in it.  That is the
configuration option that the kernel needs to have enabled in order to
build the module.  In the above example, the option
<literal>CONFIG_E1000</literal> is the configuration option that we are
looking for.
</para>

<para>
Take the configuration option that we have found, and run the kernel
menu configuration tool:
<screen>
$ <userinput>make menuconfig</userinput>
</screen>
Then press the <literal>/</literal> key and type in the configuration
option, minus the <literal>CONFIG_</literal> portion of the string:
<figure id="config_search">
<title>Searching in menuconfig</title>
<graphic fileref="images/config_search.png" scalefit="1"/>
</figure>
</para>

<para>
The kernel configuration system will then tell you the exact location where
to select the option to enable this module:
<figure id="config_search_found">
<title>Result of searching in menuconfig</title>
<graphic fileref="images/config_search_found.png" scalefit="1"/>
</figure>
</para>

<para>
So, to enable the module <literal>e1000</literal> to be built into the
kernel the following configuration option must be enabled:
<screen>
Device Drivers
    Network device support
        [*] Network device support
            Ethernet (1000 Mbit)
	    [*] Intel(R) PRO/1000 Gigabit Ethernet support
</screen>
</para>

</sect3>

<sect3>
<title>Another subsection title?</title>

<para>
The steps above will work for any type of working device in the kernel.  As
another example, let us look at a USB to serial converter that is present
in the system.  It is currently connected to the
<literal>/dev/ttyUSB0</literal> port, so we need to look in the
<literal>sysfs</literal> tty section:
<screen>
$ <userinput>ls /sys/class/tty/ | grep USB</userinput>
ttyUSB0
</screen>
And we can trace through <literal>sysfs</literal> for this device to find
the controlling module:
<screen>
$ <userinput>basename `readlink /sys/class/tty/ttyUSB0/device/driver/module`</userinput>
pl2303
</screen>
Then search the kernel source tree to find the configuration option that we
need to enable:
<screen>
$ <userinput>cd ~/linux/linux-2.6.17.8</userinput>
$ <userinput>find -type f -name Makefile | xargs grep pl2303</userinput>
./drivers/usb/serial/Makefile:obj-$(CONFIG_USB_SERIAL_PL2303) += pl2303.o
</screen>
Then use the kernel configuration tool to find the proper option to enable
in order to set the <literal>CONFIG_USB_SERIAL_PL2303</literal> option:
<figure id="config_search_pl2303">
<title>Searching for <literal>USB_SERIAL_PL2303</literal></title>
<graphic fileref="images/config_search_pl2303.png" scalefit="1"/>
</figure>
which results in the following information:
<figure id="config_search_pl2303_found">
<title>Result of searching for <literal>USB_SERIAL_PL2303</literal></title>
<graphic fileref="images/config_search_pl2303_found.png" scalefit="1"/>
</figure>
This shows exactly where to find the <literal>USB Prolific 2303 Single Port
Serial Driver</literal> option that is needed to control this device
properly.
</para>

</sect3>

</sect2>
</sect1>

<sect1>
<title>No help from the distro</title>

<para>
Sometimes you do not have the option of getting a distribution kernel
working on a machine in order to determine what kernel module is needed to
drive the hardware.  Or you have added new hardware to your system, and you
need to figure out what kernel configuration option needs to be enabled to
get it to work properly.  This section will help you determine how to find
that configuration option to get the hardware up and running.
</para>

<sect2>
<title>PCI devices</title>

<para>
</para>

</sect2>


<sect2>
<title>USB devices</title>

<para>
</para>

</sect2>
</sect1>


</chapter>

<!-- vim: set ai tw=72 : -->
